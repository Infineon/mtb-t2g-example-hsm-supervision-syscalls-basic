/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "cy_pdl.h"
#include "cyhal.h"
#include "cybsp.h"
#include "cy_retarget_io.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to decide if both CM7 needs to be enabled. Note that the main file for CM7_1 is empty */
#define CM7_DUAL                            0

/* For IPC handling */
/* IPC channel used for system calls. Assumption is that system call requests come only from CM7_0. Hence fixing the
 * channel to 1. If multiple masters trigger system calls, then the system call interrupt handler shall first check
 * IPC_INTR0_INTR to find which IPC_STRUCT has a pending system call request, and only access the respective
 * IPC_STRUCT registers  */
#define USED_IPC_CHANNEL                    1
/* Error code set by HSM (CM0+) when supervision is not approved */
#define HSM_SUPERVISION_ERROR               0x11223344
/* IPC Interrupt 0 is used for system calls */
#define IPC_NOTIFY_INT_NUMBER               0
/* This interrupt number can be used by the host for release event if needed. Currently not used in the project */
#define IPC_RELEASE_INT_NUMBER              3
/* System call Opcode bit position in scratch SRAM  */
#define SYS_CALL_OPCODE_SHIFT               24

/* Shift value for CPU IRQ number ('intSrc' of cy_stc_sysint_t consists of CPU IRQ number and system IRQ number) */
#define CPU_IRQ_NUMBER_SHIFT                16

/* For interrupts */
#define CPU_IRQ_IPC_NUM                     NvicMux2_IRQn
#define CPU_IRQ_IPC_PRIORITY                1UL
#define CPU_IRQ0_IPC_SYSCALL                NvicMux0_IRQn
#define CPU_IRQ1_IPC_SYSCALL                NvicMux1_IRQn

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
/* Variable to connect IPC Interrupt Structure 0 interrupt to CPU Interrupt IRQ2 */
static cy_stc_sysint_t syscallIpcNotifyInt =
{
    .intrSrc = ((CPU_IRQ_IPC_NUM << CPU_IRQ_NUMBER_SHIFT) | (cy_en_intr_t)(cpuss_interrupts_ipc_0_IRQn)),
    /* setting lower priority for this interrupt than the system call interrupts */
    .intrPriority = CPU_IRQ_IPC_PRIORITY
};

/* Variables for IPC handling */
static uint32_t scratchAddr;
static uint32_t scratchData;
static uint32_t intr;
static uint32_t interruptMasked;

/* Variable to store the received character through UART terminal */
static uint8_t readChar = 0;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void superviseSyscallInterrupt(void);
static void checkHsmApproval(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/**********************************************************************************************************************
 * Function Name: superviseSyscallInterrupt
 * Summary:
 * This function is invoked when IPC interrupt structure 0 interrupt gets triggered due to a notification
 * request coming from the Host CPU (CM7_0). This function then calls checkHsmApproval()to further
 * process the received system call.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void superviseSyscallInterrupt(void)
{
    printf("\r\nHSM System Call Supervisor Activated\r\n");
    checkHsmApproval();
}

/**********************************************************************************************************************
 * Function Name: checkHsmApproval
 * Summary:
 *  This function opens up the UART terminal from HSM context to decide if the received system call must be propagated
 *  to SROM or not. In practical situations, the HSM could decide propagation of system calls to SROM based on 
 *  different conditions. For example, HSM can check if a crypto operation is ongoing and if yes, then reject the 
 *  system call. The UART terminal is just to mimic similar conditions. User presses the character 'Y' or 'y' to 
 *  forward the system call to SROM.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void checkHsmApproval(void)
{
    /* Retrieve the Scratch address from IPC and the data in the scratch address */
    if (CY_IPC_DRV_SUCCESS != Cy_IPC_Drv_ReadMsgWord(Cy_IPC_Drv_GetIpcBaseAddress(USED_IPC_CHANNEL), &scratchAddr))
    {
        CY_ASSERT(0);
    }
    scratchData = CY_GET_REG32(scratchAddr);

    printf("\r\nSystem call received from Host with Opcode: 0x%02X\r\n",
            (uint8_t)(scratchData >> SYS_CALL_OPCODE_SHIFT));

    /* User decides if the system call can be forwarded to SROM to mimic a real HSM module */
    printf("\r\nApprove the system call? Press 'Y' or 'y' for YES, other character for NO\r\n");

    /* Wait till user presses a character */
    if (CY_RSLT_SUCCESS == cyhal_uart_getc(&cy_retarget_io_uart_obj, &readChar, 0))
    {
        /* Echo the pressed character */
        if (CY_RSLT_SUCCESS != cyhal_uart_putc(&cy_retarget_io_uart_obj, readChar))
        {
            CY_ASSERT(0);
        }

        /* Check if user pressed 'y' or 'Y' or other character */
        switch(readChar)
        {
            /* User/HSM decides to forward the system call to SROM */
            case 'y' :
            case 'Y':
                printf("\r\nHSM approved the system call. Forwarding the system call to SROM\r\n");

                /* Trigger system call Interrupt IRQ0 in Software. After this step, CM0+ executes
                 * the system call from SROM. The SROM code will clear the IPC interrupt and releases the IPC
                 * once the system call execution is complete */
                NVIC_SetPendingIRQ((IRQn_Type) NvicMux0_IRQn);
                break;

            default:
                /* Set an error code to the scratch SRAM so that Host/CM7_0 can understand that HSM did not 
                 * approve system call */
                *((volatile uint32_t *)(scratchAddr)) = HSM_SUPERVISION_ERROR;

                /* Get details of the IPC interrupt */
                intr = Cy_IPC_Drv_GetInterruptStatusMasked(Cy_IPC_Drv_GetIntrBaseAddr(IPC_NOTIFY_INT_NUMBER));
                interruptMasked = Cy_IPC_Drv_ExtractAcquireMask(intr);

                /* Check if the interrupt is caused by the notifier channel (CM7_0 in this case) */
                if (interruptMasked == (1uL << USED_IPC_CHANNEL))
                {
                    /* Clear the interrupt since it is not cleared by SROM */
                    Cy_IPC_Drv_ClearInterrupt(Cy_IPC_Drv_GetIntrBaseAddr(IPC_NOTIFY_INT_NUMBER),
                            CY_IPC_NO_NOTIFICATION, interruptMasked);

                    /* Release the IPC channel since the IPC is not released by SROM */
                    Cy_IPC_Drv_ReleaseNotify(Cy_IPC_Drv_GetIpcBaseAddress(USED_IPC_CHANNEL),
                            (1u << IPC_RELEASE_INT_NUMBER));
                }
                 break;
        }
        readChar = 0;
    }
}

/**********************************************************************************************************************
 * Function Name: main
 * Summary:
 *  This is the main function.
 * Parameters:
 *  none
 * Return:
 *  int
 **********************************************************************************************************************
*/
int main(void)
{
    cy_rslt_t result;

    /* Initialize the device and board peripherals */
    result = cybsp_init() ;
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Initialize retarget-io to use the debug UART port */
    result = cy_retarget_io_init(CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX,
             CY_RETARGET_IO_BAUDRATE);

    /* retarget-io init failed. Stop program execution */
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* enable interrupts */
    __enable_irq();

    /* \x1b[2J\x1b[;H - ANSI ESC sequence for clear screen */
    printf("\x1b[2J\x1b[;H");
    printf("********************************************************************************\r\n");
    printf("                             HSM System Call Supervisor\r\n");

    /* Delay added to finish printing the above messages */
    Cy_SysLib_Delay(100);

    /* Enable CM7_0/1. CY_CORTEX_M7_APPL_ADDR is calculated in linker script, check it in case of problems. */
    Cy_SysEnableCM7(CORE_CM7_0, CY_CORTEX_M7_0_APPL_ADDR);

    /* Check if CM7_1 also needs to be enabled */
    #if CM7_DUAL
        Cy_SysEnableCM7(CORE_CM7_1, CY_CORTEX_M7_1_APPL_ADDR);
    #endif

    /* Since system call supervision is enabled, set the same highest priority for IRQ0 and IRQ1. Startup would have
     * configured low priority for IRQ0 */
    NVIC_SetPriority((IRQn_Type) CPU_IRQ0_IPC_SYSCALL, 0);
    NVIC_SetPriority((IRQn_Type) CPU_IRQ1_IPC_SYSCALL, 0);

    /* Setup IPC interrupt line. SystemCallSupervisor will be the supervision interrupt handler */
    Cy_SysInt_Init(&syscallIpcNotifyInt, superviseSyscallInterrupt);

    /* Enable the CPU interrupt 2 invoke SystemCallSupervisor */
    NVIC_EnableIRQ((IRQn_Type) CPU_IRQ_IPC_NUM);

    for(;;)
    {
        /* Empty for loop */
    }
}

/* [] END OF FILE */
